\documentclass{article}
\parindent 0pt
\title{Replication Script to JSS Submission 1518:\\
\textsl{Flexible Simulation of Event Histories: A~Guide for the \textsf{R}~Add-on~Package~\texttt{simMSM}}}
\author{Holger Reulen\\ University of G\"ottingen}
\date{\today}
\begin{document}
\maketitle
\SweaveOpts{concordance=TRUE}
\tableofcontents
<<>>=
options(prompt = " ", continue = "  ")
install.packages("simMSM")
library("simMSM")
@
%%%%%%%%%%%%%%%
%% Section 1 %%
%%%%%%%%%%%%%%%
\section{Two State-type Model with Time-varying Effects and Time-change Covariates}
Build transition-type definition matrix on your own:
<<>>=
tra2 <- matrix(ncol = 2, nrow = 2, data = FALSE)
tra2[1, 2] <- tra2[2, 1] <- TRUE
tra2
@
Or use function \texttt{transMat} from R add-on package \texttt{mstate}:
<<>>=
library("mstate")
tra2 <- !is.na(transMat(list(c(2), c(1))))
tra2
@
Use \texttt{mplskeleton} to construct a skeleton of the model parameter list \texttt{mpl}:
<<>>=
mpl <- mplskeleton(tmat = tra2)
str(mpl)
@
Parametrize the model and complete \texttt{mpl}:
<<>>=
mpl[[1]]$bhr[[2]] <- mpl[[2]]$bhr[[1]] <- function(t){return(0.5)}
## time-varying x2 and time-varying f(x2):
mpl[[1]]$eta[[2]] <- function(x.i, t){
  ifelse(t < 5, 
         return(1.0 * x.i[1] + 0.5 * x.i[2]), 
         return(1.0 * x.i[1] + 1.0 * x.i[3]))}
## time-varying x2 and time-varying f(x1):
mpl[[2]]$eta[[1]] <- function(x.i, t){
  ifelse(t < 5, 
         return(-0.5 * x.i[1] + 0.5 * x.i[2]), 
         return( 1.0 * x.i[1] + 0.5 * x.i[3]))}
@
Simulate event histories:
<<>>=
set.seed(123)
N <- 500
X <- matrix(nrow = N, ncol = 2, rnorm(2 * N))
X <- cbind(X, X[, 2] + runif(N)/10)
colnames(X) <- c("x1", "x2.t1", "x2.t2")
head(X)
Xstruc <- matrix(ncol = 2, nrow = 2, data = 0)
rownames(Xstruc) <- c("t1", "t2")
colnames(Xstruc) <- c("x1", "x2")
Xstruc[, 1] <- 1
Xstruc[, 2] <- c(2, 3)
Xstruc
d <- simeventhistories(n = N, mpl = mpl, X = X, max.time = 10, 
                       change.times = c(5), Xstruc = Xstruc)
head(d$msm.basics)
head(d$ttsce[, 1:7])
head(d$tt.indicators)
@
Nelson-Aalen estimator of the cumulative hazard rate functions:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=nae>>=
plotnae(d = d$msm.basics, mpl = mpl, xlim = c(0, 15))
abline(a = 0, b = 0.5, col = "darkgrey")
@

Stratified partial likelihood modelling:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=cph>>=
m <- coxph(Surv(entry, exit, delta) ~ x1.12.t1 + x2.12.t1 + x1.12.t2 + 
             x2.12.t2 + x1.21.t1 + x2.21.t1 + x1.21.t2 + x2.21.t2 + 
             strata(trans), data = data.frame(d$msm.basics, d$ttsce))
round(summary(m)$coef[, c(1, 5)], 5)
plotcph(m)
points(c(c(1, 0.5, 1 - 1, 1 - 0.5, -0.5, 0.5, 1 - (-0.5), 0.5 - 0.5)), 
       pch = 16, col = "darkgrey")
@

Breslow estimate for cumulative hazard:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=be>>=
plotbe(m, mpl, xlim = c(0, 15), ylim = c(0, 10))
abline(a = 0, b = 0.5, col = "darkgrey")
@
%%%%%%%%%%%%%%%
%% Section 2 %%
%%%%%%%%%%%%%%%
\section{Illness-death Model with Recovery, a Non-linear Baseline Hazarad Rate Function and Non-linear Covariate Effects}
Prepare the simulation of event histories:
<<>>=
library("simMSM")
traIDM <- matrix(nrow = 3, ncol = 3, FALSE)
traIDM[1, 2] <- traIDM[1, 3] <- traIDM[2, 1] <- traIDM[2, 3] <- TRUE
## Or use mstate:
library("mstate")
traIDM <- !is.na(transMat(list(c(2, 3), c(1, 3), c())))
traIDM
## Build up mpl:
mpl <- mplskeleton(tmat = traIDM)
mpl[[1]]$bhr[[2]] <- function(t){0.5 + 0.4 * sin(t)}
mpl[[1]]$bhr[[3]] <- mpl[[2]]$bhr[[1]] <- 
  mpl[[2]]$bhr[[3]] <- function(t){0.5}
mpl[[1]]$eta[[2]] <- function(x.i, t){ 3 * (x.i^2)}
mpl[[1]]$eta[[3]] <- function(x.i, t){-3 * (x.i^2)}
mpl[[2]]$eta[[1]] <- mpl[[2]]$eta[[3]] <- 
  function(x.i, t){0.5 * x.i}
## simulate design matrix and event history data:
set.seed(123)
N <- 500
X <- matrix(ncol = 1, nrow = N, data = runif(N) - 0.5)
colnames(X) <- c("x")
Xstruc <- matrix(ncol = 1, nrow = 1, data = 1)
rownames(Xstruc) <- c("t1")
colnames(Xstruc) <- c("x")
Xstruc
d <- simeventhistories(n = N, mpl = mpl, X = X, max.time = 10, 
                       change.times = NULL, Xstruc = Xstruc)
head(d$msm.basics)
@

Nelson-Aalen estimators:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=nae>>=
plotnae(d = d$msm.basics, mpl)
@

Convert to long data format and estimate a stratified Cox proportional hazards (partial likelihood) model:
<<>>=
ld <- tolongformat(d, mpl = mpl)
head(ld$msm.basics)
head(ld$tt.indicators)
m <- coxph(Surv(entry, exit, delta) ~ I(x.12^2) + I(x.13^2) + 
             x.21 + x.23 + strata(trans), 
           data = data.frame(ld$msm.basics, ld$ttsce))
round(summary(m)$coef[, c(1, 5)], 5)
@

Cox model coefficient illustration:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=cph>>=
plotcph(m)
points(c(3, -3, 0.5, 0.5), col = "darkgrey", pch = 16)
@

Breslow estimator:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=nae>>=
plotbe(m, mpl)
@

BayesX:
<<>>=
d <- data.frame(d$msm.basics, d$tt.indicators)
install.packages("BayesXsrc")
library("BayesXsrc")
p <- "delimiter = ;
dataset dat;
dat.infile using d.raw;
remlreg simmsm;
simmsm.mregress 
trans12=exit(baseline,gridchoice=all,nrknots=30,lambdastart=5)+x(psplinerw2):
trans13=exit(baseline,gridchoice=all,nrknots=30,lambdastart=5)+x(psplinerw2):
trans21=exit(baseline,gridchoice=all,nrknots=30,lambdastart=5)+x(psplinerw2):
trans23=exit(baseline,gridchoice=all,nrknots=30,lambdastart=5)+x(psplinerw2),
family=multistate lefttrunc=entry state=from maxit=1000 using dat;
delimiter = return;"
write.table(d, row.names = FALSE, quote = FALSE, file = "d.raw")
writeLines(p, con = "prg")
run.bayesx(prg = "prg", verbose = FALSE)
@

Prepare plotting the results:
<<>>=
setwd("./output/")
log.bhr <- beta.fixed <- beta.x <- vector("list", 4)
log.bhr[[1]] <- read.table("simmsm_f_exit_logbaseline.res", header=T)
log.bhr[[2]] <- read.table("simmsm_f_2_exit_logbaseline.res", header=T)
log.bhr[[3]] <- read.table("simmsm_f_3_exit_logbaseline.res", header=T)
log.bhr[[4]] <- read.table("simmsm_f_4_exit_logbaseline.res", header=T)
beta.fixed[[1]] <- read.table("simmsm_FixedEffects.res", header=T)
beta.fixed[[2]] <- read.table("simmsm_FixedEffects_2.res", header=T)
beta.fixed[[3]] <- read.table("simmsm_FixedEffects_3.res", header=T)
beta.fixed[[4]] <- read.table("simmsm_FixedEffects_4.res", header=T)
beta.x[[1]] <- read.table("simmsm_f_x_pspline.res", header=T)
beta.x[[2]] <- read.table("simmsm_f_2_x_pspline.res", header=T)
beta.x[[3]] <- read.table("simmsm_f_3_x_pspline.res", header=T)
beta.x[[4]] <- read.table("simmsm_f_4_x_pspline.res", header=T)
setwd("../")
plot.bhr <- function(log.bhr, beta.fixed, t.max){
  index.for.plot <- c("12,0", "13,0", "21,0", "23,0")
  par(mfrow = c(2, 2), mar = c(3.1, 3.1, 0.1, 0.1), tcl = -0.3)
  for(q in 1:4){
    plot(1, 1, ylim=c(0, 3), xlim=c(0, t.max), 
         type = "n", xaxt = "n", yaxt = "n", 
         xlab = "", ylab = "", bty = "n")
    axis(1, at = c(0, 4, 8, 12), label = FALSE)
    mtext(side = 1, text = c(0, 4, 8, 12), at = c(0, 4, 8, 12), 
          line = 0.5, cex = 0.5)
    axis(2, label = FALSE, at = 0:2)
    mtext(side = 2, text = 0:2, at = 0:2, line = 0.5, cex = 0.5)
    mtext("t", side = 1, line = 1.4, cex = 0.7)
    mtext(bquote(paste(lambda[.(index.for.plot[q])],(t))), side = 2, 
          line = 1.4, cex = 0.7)
    hilf <- beta.fixed[[q]]
    if(q == 1){
      ## 0.255 = mean( 3 * (seq(-0.5, 0.5, length = 100)^2))
      intercept <- hilf$pmode[1] - 0.255
    }
    if(q == 2){
      ## 0.255 = mean( 3 * (seq(-0.5, 0.5, length = 100)^2))
      intercept <- hilf$pmode[1] + 0.255
    }
    if(q %in% c(3, 4)){
      intercept <- hilf$pmode[1]
    }
    hilf <- log.bhr[[q]]
    polygon(c(hilf$exit, rev(hilf$exit)), 
            exp(intercept + c(hilf$ci95lower, rev(hilf$ci95upper))), 
            border = "NA", col = "lightgrey")
    lines(hilf$exit, exp(hilf$pmode + intercept), col = 1, lwd = 2)
    time <- seq(0, t.max, length = 100)
    if(q == 1){lines(time, (0.5 + 0.4 * sin(time)), lwd = 2, lty = 2)}
    if(q == 2){lines(time, (0.5 + 0*time), lwd = 2, lty = 2)}
    if(q == 3){lines(time, 0.5 + 0*time, lwd = 2, lty = 2)}
    if(q == 4){lines(time, 0.5 + 0*time, lwd = 2, lty = 2)}
  }
}
plot.spline <- function(beta.x){
  index.for.plot <- c("12,x", "13,x", "21,x", "23,x")
  par(mfrow = c(2, 2), mar = c(3.1, 3.1, 0.1, 0.1), tcl = -0.3)
  for(q in 1:4){
    plot(1, 1, ylim = c(-1.2, 1.2), xlim=c(-0.5, 0.5), type = "n", 
         xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty = "n")
    axis(1, at = c(-0.5, 0, 0.5), label = FALSE)
    mtext(side = 1, text = c(-0.5, 0, 0.5), at = c(-0.5, 0, 0.5), 
          line = 0.5, cex = 0.5)
    axis(2, label = FALSE, at = -1:1)
    mtext(side = 2, text = -1:1, at = -1:1, line = 0.5, cex = 0.5)
    mtext("x", side = 1, line = 1.4, cex = 0.7)
    mtext(bquote(f[.(index.for.plot[q])](x)), side = 2, 
          line = 1.4, cex = 0.7)
    if(q == 1){
       ## 0.255 = mean( 3 * (seq(-0.5, 0.5, length = 100)^2))
      intercept <-  0.255
    }
    if(q == 2){
      ## -0.255 = mean(-3 * (seq(-0.5, 0.5, length = 100)^2))
      intercept <- -0.255
    }
    if(q %in% c(3, 4)){
      intercept <- 0
    }
    hilf <- beta.x[[q]]
    polygon(c(hilf$x, rev(hilf$x)), 
            intercept + c(hilf$ci95lower, rev(hilf$ci95upper)), 
            border = "NA", col = "lightgrey")
    lines(hilf$x, hilf$pmode + intercept, col = 1, lwd = 2)
    x <- seq(-0.5, 0.5, length = 100)
    if(q == 1){lines(x, 3*(x^2), lwd = 2, lty = 2)}
    if(q == 2){lines(x,-3*(x^2), lwd = 2, lty = 2)}
    if(q == 3){lines(x, 0.5 * x, lwd = 2, lty = 2)}
    if(q == 4){lines(x, 0.5 * x, lwd = 2, lty = 2)}
  }
}
@

BayesX baseline hazard rate function estimates:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=bayesX_bhr>>=
plot.bhr(log.bhr, beta.fixed, t.max = print(max(d$exit)))
@

BayesX covariate effect function estimates:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=bayesX_x>>=
plot.spline(beta.x)
@
%%%%%%%%%%%%%%%
%% Section 3 %%
%%%%%%%%%%%%%%%
\section{Illness-death Model with Partial Markov Influences}
Model build up in a general way:
<<>>=
traIDM <- matrix(nrow = 3, ncol = 3, FALSE)
traIDM[1, 2] <- traIDM[1, 3] <- traIDM[2, 1] <- traIDM[2, 3] <- TRUE
mpl <- mplskeleton(tmat = traIDM)
mpl[[1]]$bhr[[2]] <- mpl[[1]]$bhr[[3]] <- mpl[[2]]$bhr[[1]] <- 
                     mpl[[2]]$bhr[[3]] <- function(t){0.25}
mpl[[1]]$eta[[2]] <- mpl[[1]]$eta[[3]] <- mpl[[2]]$eta[[1]] <- 
  mpl[[2]]$eta[[3]] <- function(x.i, t){
    ifelse(t < 5, 
      return(0.5 * x.i[1]), 
      return(0.5 * x.i[2]))}
set.seed(123)
N <- 500
X <- matrix(nrow = N, ncol = 1, rnorm(N))
X <- cbind(X, X[, 1] + rnorm(N)/10)
colnames(X) <- c("x1.t1", "x1.t2")
Xstruc <- matrix(ncol = 1, nrow = 2, data = 0)
rownames(Xstruc) <- c("t1", "t2")
colnames(Xstruc) <- c("x1")
Xstruc[, 1] <- c(1, 2)
Xstruc
@
Now set-up the partial Markov influences. 
Function \texttt{partial.markov.x} has to take 5 input arguments representig vectors of past history information. 
They have to take names \texttt{entry}, \texttt{exit}, \texttt{from}, \texttt{to}, and \texttt{delta}:
<<>>=
partial.markov.x <- function(entry, exit, from, to, delta){
  count.12 <- sum(as.numeric((from == 1) & (to == 2) & (delta == 1)))
  count.21 <- sum(as.numeric((from == 2) & (to == 1) & (delta == 1)))
  return(c(count.12, count.21))}
@
The object \texttt{partial.markov.eta} is a list of lists in analogy to \texttt{mpl}:
<<>>=
partial.markov.eta <- pmeskeleton(traIDM)
str(partial.markov.eta)
partial.markov.eta[[1]][[2]] <- function(x){return( 0.25 * x[1])}
partial.markov.eta[[1]][[3]] <- function(x){return( 0.5 * x[1])}
partial.markov.eta[[2]][[1]] <- function(x){return(-0.5 * x[1] + 0.25 * x[2])}
partial.markov.eta[[2]][[3]] <- function(x){return(0)}
@
Event history simulation:
<<>>=
d <- simeventhistories(n = N, mpl = mpl, X = X, max.time = 10, 
                       change.times = c(5), Xstruc = Xstruc, 
                       partial.markov.x = partial.markov.x, 
                       partial.markov.eta = partial.markov.eta)
@
Nelson-Aalen estimator of the cumulative hazard rate functions:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=nae>>=
plotnae(d$msm.basics, mpl = mpl)
abline(a = 0, b = 0.25, col = "darkgrey")
@

Stratified partial likelihood modelling:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=cph>>=
ld <- tolongformat(d = d, mpl = mpl)
head(ld$msm.basics, n = 10)
head(ld$ttsce[, 1:6], n = 10)
m <- coxph(Surv(entry, exit, delta) ~ x1 + 
             pm.x1.12 + pm.x1.13 + pm.x1.21 + pm.x2.21 + 
             strata(trans), 
           data = data.frame(ld$msm.basics, ld$ttsce))
plotcph(m)
points(c(0.5, 0.25, 0.5, -0.5, 0.25), pch = 16, col = "darkgrey")
@

Breslow estimate for cumulative hazard:
<<fig=TRUE, pdf=TRUE, height=5, width=7, label=be>>=
plotbe(m, mpl = mpl)
abline(a = 0, b = 0.25, col = "darkgrey")
@
\end{document}