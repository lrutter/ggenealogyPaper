\documentclass[article,shortnames]{jss}
\usepackage{float}
\usepackage[]{media9}

\usepackage{tcolorbox}% http://ctan.org/pkg/tcolorbox
\definecolor{frameCol}{rgb}{0.122, 0.435, 0.698}% Rule colour
\definecolor{bgndCol}{rgb}{.66,.66,.66}% Rule colour
\makeatletter
\newcommand{\mybox}[1]{%
  \setbox0=\hbox{#1}%
  \setlength{\@tempdima}{\dimexpr\wd0+13pt}%
  \begin{tcolorbox}[colframe=frameCol,colback=bgndCol,boxrule=0.5pt,arc=4pt,
      left=6pt,right=6pt,top=6pt,bottom=6pt,boxsep=0pt,width=\@tempdima]
    #1
  \end{tcolorbox}
}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Lindsay Rutter\\Iowa State University \And 
        Susan VanderPlas\\Iowa State University \And
        Dianne Cook\\Monash University\And
        Michelle A. Graham\\Iowa State University}
\title{\pkg{ggenealogy}: An \proglang{R} Package for Visualizing Genealogical Data}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Lindsay Rutter, Susan VanderPlas, Di Cook} %% comma-separated
\Plaintitle{ggenealogy: An R Package for Visualizing Genealogical Data} %% without formatting
\Shorttitle{\pkg{ggenealogy}: An \proglang{R} Package for Visualizing Genealogical Data} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  This paper introduces \pkg{ggenealogy} (\citealt{ggen}), a developing \proglang{R} software package that provides tools for searching through genealogical data, generating basic statistics on their graphical structures using parent and child connections, parsing and performing calculations on branches of interest, and displaying the results. It is possible to draw the genealogy in relation to variables related to the nodes, and to determine and display the shortest path distances between the nodes. Production of pairwise distance matrices and genealogical diagrams constrained on generation are also available in the visualization toolkit. The tools are being tested on a dataset with milestone cultivars of soybean varieties (\citealt{soybean}) as well as on a web-based database of the academic genealogy of mathematicians (\citealt{mgp}). The latest stable package version is available in source and binary form on the Comprehensive \proglang{R} Archive Network.}

\Keywords{genealogy, data visualization, statistical graphics, exploratory data analysis, interactive, \proglang{R}}
\Plainkeywords{genealogy, data visualization, statistical graphics, exploratory data analysis, interactive, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{50}
%% \Issue{9}
%% \Month{June}
%% \Year{2012}
%% \Submitdate{2012-06-04}
%% \Acceptdate{2012-06-04}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Lindsay Rutter\\
  Bioinformatics and Computational Biology Program\\
  Iowa State University\\
  2014 Molecular Biology Building\\
  Ames, IA, 50011, United States of America\\
  E-mail: \email{lrutter@iastate.edu}\\
  URL: \url{https://github.com/lrutter/}\\

  Susan VanderPlas\\
  Department of Statistics\\
  Iowa State University\\
  2413 Snedecor Hall\\
  Ames, IA, 50011, United States of America\\
  E-mail: \email{srvanderplas@gmail.com}\\
  URL: \url{https://github.com/srvanderplas/}\\
  
  Dianne Cook\\
  Department of Econometrics and Business Statistics\\
  Monash University\\
  E869 Menzies Building\\
  20 Chancellors Walk\\
  Clayton, VIC 3800, Australia\\
  E-mail: \email{dicook@monash.edu}\\
  URL: \url{https://github.com/dicook/}\\

  Michelle Graham\\
  USDA-Agriculture Research Service, Corn Insects and Crop Genetics Research Unit\\
  Department of Agronomy, Iowa State University\\
  1565 Agronomy Building\\
  Ames, IA, 50011, United States of America\\
  E-mail: \email{michelle.graham@ars.usda.gov}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/512/507-7103
%% Fax: +43/512/507-2851

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

%% \section[About Java]{About \proglang{Java}}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.

\section{Introduction}

Genealogy is the study of parent-child relationships. By tracing through parent-child lineages, genealogists can study the histories of features that have been modified over time. Comparative geneticists, computational biologists, and bioinformaticians commonly use genealogical tools to better understand the histories of novel traits arising across biological lineages. For example, desirable modifications in crops could include an increase in protein yield or an increase in disease resistance, and genealogical structures could be used to assess how these desirable traits developed. At the same time, genealogical lineages can also be used to assess detrimental features, such as to determine the origin of hazardous traits in rapidly-evolving viruses.

Genealogical structures can also serve as informative tools outside of a strict biological sense. For instance, we can trace mentoring relationships between students and dissertation supervisors with the use of academic genealogies. This can allow us to understand the position of one member in the larger historical picture of academia, and to accurately preserve past relationships for the knowledge of future generations. Similarly, linguistic genealogies can be used to decipher the historical changes of vocabulary and grammatical features across related languages. In short, there is a diverse array of disciplines that can elicit useful information about features of interest by using genealogical data.

In all these examples, the genealogical relationships can be represented visually. Access to various types of plotting tools can allow scientists and others to more efficiently and accurately explore features of interest across the genealogy. We introduce here a developing visualization toolkit that is intended to assist users in their exploration and analysis of genealogical structures. In this paper, we demonstrate the main tools of the software package \pkg{ggenealogy} using two example genealogical datasets, one of soybean cultivars (\citealt{soybean}) and the other of academic mathematicians (\citealt{mgp}).

\section{Available software}

Publishing in the open source \proglang{R} statistical programming language allows for tools to be distributed and modified at ease, encourages cross-platform collaboration, and provides a foundation for effective and aesthetic data visualization from the grammar of graphics. There are several useful \proglang{R} packages that offer tools for analyzing and visualizing genealogical datasets. Here, we introduce these packages, and emphasize the new features that \pkg{ggenealogy} brings to this collection of work.

The \proglang{R} package \pkg{pedigree} is named after the standardized chart used to study human family lines, and sometimes used to select breeding of animals, such as show dogs (\citealt{ped}). This package does provide tools that perform methods on parent-child datasets, such as rapidly determining the generation count for each member in the pedigree. However, it does not provide any visualization tools.

Another \proglang{R} package called \pkg{kinship2} does produce basic pedigree charts (\citealt{kin}). In Figure \ref{fig:kinshipFig}, we provide an example pedigree chart from the \pkg{kinship2} package vignette. This pedigree chart adheres to the standard set of symbols used for visualizing genealogical structures: Males are represented with squares and females with circles. Parents are connected to each other by horizontal lines, and to their children by vertical lines. Siblings are connected by horizontal sibship lines. Even though this standard pedigree chart creates powerful charts that can be applied across many applications, it cannot provide unequivocal information in many situations where inter-generational breeding occurs, as is often the case in agronomic genealogical lineages.

We demonstrate how the standardized pedigree charts in the \pkg{kinship2} package generate ambiguous results in such scenarios by superimposing a hypothetical inter-generational breeding case in Figure \ref{fig:kinshipFig}. In that figure, each generation is defined by its position on the vertical axis, with the first generation containing individuals 201 and 202. We superimposed green-highlighted individual 215 onto the pedigree chart for explanatory purposes. Its parents are individuals 201 and 206, which are from generations one and two, respectively, and have a parent-child relationship between themselves. As an offspring of a parent-child relationship, individual 215 is both a second and third generation individual. Hence, individual 215 should be displayed in both second and third generational positions on the vertical axis. However, most standard pedigree tools only allow for an individual to be displayed once. As a result, in special cases where inter-generational breading occurs, such as in agronomic applications, most standardized tools for visualizing genealogical information ambiguously portray the genealogical dataset by generation count.

In the \pkg{kinship2} package, if an individual cannot be represented with only one instance, then it will be completely copied and connected with dotted lines to the relevant individuals. However, the package requires that each child has exactly zero or two parents; if a child has two parents, then one must be female and one must be male. These requirements preclude certain genealogical datasets from being plotted by generation count, especially when their complexity increases with inter-generational breeding.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.65\textwidth]{kinshipFig}}
    \caption{Example pedigree chart from the \pkg{kinship2} package, where the vertical axis denotes generation count. We superimposed green-highlighted individual 215 for explanatory purposes. As an offspring of a parent-child relationship, individual 215 is both a second and third generation individual. Hence, it should be displayed twice on the vertical axis, once for each of its generation counts. However, most standard pedigree tools only allow for an individual to be displayed once. In the \pkg{kinship2} package, individuals can indeed be displayed more than once. However, each child must have zero or two parents (one male and one female). These restrictions make it impossible to plot genealogical data by generation count in cases where there are many inter-generational breedings.}
    \label{fig:kinshipFig}
\end{figure}

In addition, popular graph drawing software such as \pkg{GraphViz} and \pkg{Cytoscape} can be used to visualize genealogical structures (\citealt{graphvizCit}, \citealt{cytoscapeCit}). Graphs are defined as objects with sets of nodes and edges, where sets indicate that their comprised elements cannot be repeated. In other words, graphical structures do not allow for repeated nodes, and hence, as is the case with the aforementioned \proglang{R} packages, these popular graph plotting software cannot precisely portray the genealogical dataset in cases of inter-generational breeding.

We again illustrate this problem in Figure \ref{fig:Graph} with an example genealogy using popular graph drawing software like \pkg{GraphViz} and \pkg{Cytoscape}. Here, generation count is denoted by the vertical axis. As was shown in Figure \ref{fig:kinshipFig}, here too we superimpose a green node that has parents from two different generations. This green node is both a second and third generation individual, and should be displayed in both corresponding generation positions on the vertical axis. However, standard graph visualization tools only allow for a given node to be displayed once. As a result, this green node must be ambiguously positioned in either the second or third generation position; in the figure, it is denoted as a third generation individual. In Section \ref{remedy}, we will demonstrate \pkg{ggenealogy} plots that can remedy these problems.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.6\textwidth]{Graph}}
    \caption{Example genealogical display using popular graph software like \pkg{GraphViz} and \pkg{Cytoscape}, with generation count denoted by the vertical axis. As was shown in Figure \ref{fig:kinshipFig}, the green node has parents from two different generations, and hence must be ambiguously positioned as one of two generation counts.}
    \label{fig:Graph}
\end{figure}

\section{Package overview}

We will now provide a brief overview of the functionality of the \pkg{ggenealogy} package before going into more detail with examples later in this paper. With the \pkg{ggenealogy} package, users can convert genealogical data into graph structures. This allows for users to efficiently traverse, analyze, and elicit graph theoretical measurements on genealogical lineages (see Section \ref{ggo}). These capabilities were developed by building upon the \pkg{igraph} software (\citealt{igraph}).

Additionally, the \pkg{ggenealogy} package allows for users to plot genealogical data in multiple ways. Users can obtain and plot the shortest path between two nodes of interest constrained on a variable of interest (see Section \ref{psp}), superimpose a shortest path between two nodes of interest with the entire genealogical structure constrained on a variable of interest (see Section \ref{sspt}), plot the ancestors and descendants of a node of interest constrained on generation count (see Section \ref{remedy}), and plot distance matrices based on a variable of interest (see Section \ref{pdm}).

Most of these plotting tools were developed by building upon the \pkg{ggplot2} package (\citealt{ggplot2}). As such, most of these plotting tools can be customized by appending syntax from the \pkg{ggplot2} package, as will be demonstrated in example code throughout this paper. Moreover, some of these plotting tools have interactive capabilities that were developed with the use of the \pkg{plotly} package (\citealt{plotly}) (see Subsection \ref{interaction}).

\section{Example datasets}
\label{exData}

The \pkg{ggenealogy} package comes with two example datasets, one comprises a soybean genealogy and the other comprises an academic statistician genealogy. We will introduce both example datasets in this paper to demonstrate some of the tools available in the software.

\subsection{Soybean genealogy}

We start with the soybean genealogy, which is available as a data frame structure with 390 rows and five columns. These data were collected from field trials, genetic studies, and United States Department of Agriculture (USDA) bulletins, and date as early as the first decade of the 1900s. They contain information on the copy number variants, single nucleotide polymorphisms, and protein content for each of the varieties, although we removed that information for a succinct example dataset. In this context, the software could ideally be used by agronomists who wish to study how soybean varieties are related. By referencing the visualization of the genealogical structure, these scientists may better understand genetic testing results - in this particular dataset, in terms of copy number variants, single nucleotide polymorphisms, protein content, and yield - and use that knowledge in future breeding decisions.

Each row contains information about a particular child soybean variety, including the name of the child, its yield, the year it was released, whether or not its release year was imputed, and the name of its parent. It should be noted that it typically requires many crosses over the span of one to two decades to develop a new variety that has introduced a desired trait and/or removed an undesired trait. Hence, the release year variable in this dataset represents the year in which the variety was released to the public after its development period. While the name of the child is required, the other four columns can have missing values (which are represented in \proglang{R} with the symbol NA for ``not available"). As a result, while each row does contain information about a particular child soybean variety, whether or not a given row also contains information about a parent-child relationship between a pair of soybeans depends on whether or not the parent column has a missing value.

In total, there are 230 soybean varieties in the dataset, 206 of which are children and 165 of which are parents. There are soybeans that are both children and parents. Of the children, 156 have two parents, 28 have one parent, and 22 have zero parents. There are 340 parent-child relationships in the dataset.

We can load the example dataset of soybean genealogy (\code{sbGeneal}) and examine its structure. 

\begin{CodeChunk}
\begin{CodeInput}
R> install.packages("ggenealogy")
R> library("ggenealogy")
R> data("sbGeneal")
R> str(sbGeneal)
\end{CodeInput}
\begin{CodeOutput}
'data.frame':	390 obs. of  5 variables:
 $ child      : chr  "5601T" "Adams" "A.K." "A.K. (Harrow)" ...
 $ devYear    : num  1981 1948 1910 1912 1968 ...
 $ yield      : int  NA 2734 NA 2665 NA 2981 2887 2817 NA NA ...
 $ yearImputed: logi  TRUE FALSE TRUE FALSE FALSE FALSE ...
 $ parent     : chr  "Hutcheson" "Dunfield" NA "A.K." ...
\end{CodeOutput}
\end{CodeChunk}

\subsection{Academic genealogy of statisticians}
The \pkg{ggenealogy} package also comes with an academic genealogy of statisticians; this dataset is in the form of a data frame with 8165 rows and six columns. To develop this later dataset, we contacted the \citealt{mgp}, a web-based database for the genealogy of academic mathematicians. This database, which currently contains almost 200,000 entries, is a service of the North Dakota State University Department of Mathematics and the American Mathematical Society. The Mathematics Genealogy Project contact provided us a Structured Query Language (SQL) export, and we used PostgreSQL to query the database (\citealt{psql}).

Each entry in the database contained 26 variables pertaining to an individual who received a graduate-level academic degree in mathematics. One of these variables was called ``msc" (Mathematics Subject Classification), and we selected only those entries that contained a value of 62 for this variable (coded as ``Statistics"). Furthermore, we only retained entries that had a parent if that parent was also in the field of ``Statistics". Hence, in our parent-child relationships, both the child and the parent received postbaccalaureate degrees in statistics, and the parent was the academic advisor to the child. This process resulted in 8995 entries, which we reduced to 8165 entries by removing duplicate entries. With the final data frame of 8165 entries, we only maintained six of the original 26 variables. 

Each row of the final data frame contains information about a particular child who received a graduate-level academic degree in statistics, including the name of the child, the year the child obtained the degree, the country and school from which the child obtained the degree, the thesis title of the degree awarded to the child, and the name of its parent. There are no missing values for the country and school from which the child received its degree or the name of the child; however, some of the years contain missing values (NA), and some of the parent and thesis names contain empty strings (``"). As a result, while each row does contain information about a particular child, whether or not a row also contains information about a parent-child relationship between a pair of academic statisticians depends on whether or not the parent column has an empty string.
 
In total, there are 7122 individuals in the dataset, 7122 of which are children and 872 of which are parents. Every parent is also a child, but not every child is also a parent. Of the children, two have four parents, ten have three parents, 226 have two parents, 2801 have one parent, and 4083 have no parents. There are 3291 parent-child relationships in the dataset.

We can load the example dataset of academic genealogy of statisticians (\code{statGeneal}) and examine its structure. 

\begin{CodeChunk}
\begin{CodeInput}
R> data("statGeneal")
R> dim(statGeneal)
\end{CodeInput}
\begin{CodeOutput}
[1] 8165    6
\end{CodeOutput}
\begin{CodeInput}
R> colnames(statGeneal)
\end{CodeInput}
\begin{CodeOutput}
[1] "child"    "parent"   "gradYear" "country"  "school"   "thesis" 
\end{CodeOutput}
\end{CodeChunk}

\section{Genealogical input format}

As is the case with both example data files introduced above, \pkg{ggenealogy} requires that the genealogy input file is a data frame structure with at least two columns. One column must be labeled ``child", and each case in that column must be of type character. The other column must be labeled ``parent," and each case in that column must either be of type character, type NA, or type ``". At this point, any \pkg{ggenealogy} plot that only requires information about parent-child relationships can be used.

However, some \pkg{ggenealogy} plots also make use of quantitative variable values associated with individuals in the genealogy. For these plots, the input data frame should also contain a third quantitative variable column. Each case in this quantitative variable column should be of type numeric. In the first example dataset, columns that could be used for this purpose include ``devYear", ``yield", and ``yearImputed"; in the second example dataset, the column that could be used for this purpose is ``gradYear". However, for these quantitative variable columns to successfully be used in plots, we would first need to assure that each row within them contains a numeric value (not NA). We could achieve this by filtering out or imputing certain rows that contain NA values for this column of interest. We demonstrate a filtering process for this purpose at the end of Section \ref{psp}. After that, any \pkg{ggenealogy} plot can be used.

\section{Generating a graphical object}
\label{ggo}

Most functions in the \pkg{ggenealogy} software package require an input parameter of a graph structure. Therefore, as a preprocessing step, we must first convert our original data frame structure into a graph structure. Below, we read in the \proglang{R} data file \code{sbGeneal} that is included in the package as a sample data set of soybean genealogy.

We now convert it into an \pkg{igraph} object \code{sbIG} using the function 
\code{dfToIG()}.
\begin{CodeChunk}
\begin{CodeInput}
R> sbIG <- dfToIG(sbGeneal)
R> sbIG
\end{CodeInput}
\begin{CodeOutput}
IGRAPH UNW- 230 340 -- 
+ attr: name (v/c), weight (e/n)
+ edges (vertex names):
 [1] 5601T    --Hutcheson        Adams    --Dunfield        
 [3] A.K.     --A.K. (Harrow)    Altona   --Flambeau        
 [5] Amcor    --Amsoy 71         Adams    --Amsoy           
 [7] Amsoy 71 --C1253            Anderson --Lincoln         
 [9] Bay      --York             Bedford  --Forrest         
[11] Beeson   --Kent             Blackhawk--Richland        
[13] Bonus    --C1266R           Bradley  --J74-39          
[15] Bragg    --Jackson          Bragg    --Bragg x D60-7965
+ ... omitted several edges
\end{CodeOutput}
\end{CodeChunk}

There are many statistics about the \code{sbGeneal} dataset that we may wish to know that cannot easily be obtained through images and tables. The package function \code{getBasicStatistics()} can be called, using the \code{sbIG} object as input. This will return a list of common graph theoretical measurements regarding the genealogical structure. For instance, is the whole structure connected? If not, how many separated components does it contain? In addition to these statistics, the \code{getBasicStatistics()} function will also return the number of nodes, the number of edges, the average path length, the graph diameter, and other graph theoretical information.

\begin{CodeChunk}
\begin{CodeInput}
R> getBasicStatistics(sbIG)
\end{CodeInput}
\begin{CodeOutput}
$isConnected
[1] FALSE

$numComponents
[1] 11
$avePathLength
[1] 5.333746

$graphDiameter
[1] 13
$numNodes
[1] 230

$numEdges
[1] 340
$logN
[1] 5.438079
\end{CodeOutput}
\end{CodeChunk}

\section{Plotting a shortest path}
\label{psp}

With soybean lineages, it may be useful for soybean breeders to track how two varieties are related to each other via parent-child relationships. Then, any dramatic changes in yield and other measures of interest between the two varieties can be traced across their genetic timeline. The \pkg{ggenealogy} package allows users to select two varieties of interest, and determine the shortest pathway of parent-child relationships between them, using the \code{getPath()} function. This will return a list that contains the path, along with the variety name and quantitative variable value of interest for each variety in the path. For this example, we will use the development year (from the column ``devYear") as our quantitative variable.

\begin{CodeChunk}
\begin{CodeInput}
R> pathTN <- getPath("Tokyo", "Narow", sbIG, sbGeneal, "devYear")
R> pathTN
\end{CodeInput}
\begin{CodeOutput}
$pathVertices
[1] "Tokyo"    "Volstate" "Jackson"  "R66-873"  "Narow"   
$variableVertices
[1] "1907"   "1942"   "1954.5" "1971.5" "1985"   
\end{CodeOutput}
\end{CodeChunk}

The returned path object can then be plotted using the \code{plotPath()} function.

\begin{Code}
R> plotPath(pathTN, sbGeneal, "devYear")
\end{Code}

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=\textwidth]{pathTNZB}}
    \caption{Left: The shortest path between varieties \code{Tokyo} and \code{Narow} is strictly composed of a unidirectional sequence of parent-child relationships. Right: The shortest path between varieties \code{Zane} and \code{Bedford} is not strictly composed of unidirectional parent-child relationships; they instead have a cousin-like relationship.}
    \label{fig:pathTNZB}
\end{figure}

This produces a visual that informs users of all the varieties involved in the shortest path between the two varieties of interest (see left half of Figure \ref{fig:pathTNZB}). In this plot, the release year of all varieties involved in the path are indicated on the horizontal axis, while the vertical axis has no meaning other than to simply to display the labels evenly spaced vertically. The shortest path between varieties \code{Tokyo} and \code{Narow} is composed of a unidirectional series of parent-child relationships, with \code{Tokyo} as the starting ancestor in the early 1900s, \code{Narow} as the most recent descendent in the mid 1980s, and three varieties in between.

Next, we can run the same set of functions on a different pair of varieties. First, we can call the \pkg{ggenealogy} function \code{getVariable()} using the input quantitative variable of development year. This indicates that variety \code{Bedford} was released in 1978 and variety \code{Zane} in 1985.

\begin{CodeChunk}
\begin{CodeInput}
R> getVariable("Bedford", sbGeneal, "devYear")
\end{CodeInput}
\begin{CodeOutput}
[1] 1978
\end{CodeOutput}
\begin{CodeInput}
R> getVariable("Zane", sbGeneal, "devYear")
\end{CodeInput}
\begin{CodeOutput}
[1] 1985
\end{CodeOutput}
\end{CodeChunk}

We can then create a plot showing the shortest path between these two varieties of interest. As this is a longer path, we may also consider setting the \code{fontFace} variable of the \code{plotPath()} to a value of 2, indicating we wish to boldface the two varieties of interest. In addition, as is the case with plotting tools in \pkg{ggenealogy}, we can append \pkg{ggplot2} syntax. In this case, we may wish to hard code the x-axis label from its default value of ``devYear" (the inputted quantitative variable column name) to the more readable ``Development Year".

\begin{Code}
R> pathBZ <- getPath("Bedford", "Zane", sbIG, sbGeneal, "devYear")
R> plotPath(pathBZ, sbGeneal, "devYear", fontFace = 2) + ggplot2::xlab
+    ("Development Year")
\end{Code}

The resulting plot (right half of Figure \ref{fig:pathTNZB}) allows us to quickly determine that \code{Bedford} is not a parent, grandparent, or any great grandparent of \code{Zane}. Instead, we see that these two varieties are not related through a unidirectional parent-child lineage, but instead have a cousin-like relationship. The oldest common ancestor between \code{Zane} and \code{Bedford} is the variety \code{D55-4090}, which was released in the mid 1940s.

Furthermore, as seen in the figure, for both \code{Zane} and \code{Bedford}, there are four varieties of unidirectional parent-child relationships between each of them and their common ancestor \code{D55-4090}. Hence, any feature that differentiates \code{Zane} and \code{Bedford} (protein content, yield, disease resistance, etc.) can also be examined across these two separate lineage histories.

We would like to note that the \code{plotPath()} method can be created with one or two quantitative variables that the user hard-codes. We illustrate this with the \code{sbGeneal} data frame after we subset it to remove observations that do not have values for the quantitative variable ``yield". Then, we can examine the path between the varieties \code{Clark} and \code{Lawrence} and plot how the quantitative variable ``yield" changes along the parent-child relationships of that path. Likewise, we plot how the quantitative variables ``devYear" and ``yield" both change along the parent-child relationships of that path. The output of these two calls to the \code{plotPath()} function can be viewed in Figure \ref{fig:plotPathQV2}.

\begin{Code}
R> sbFilt <- sbGeneal[complete.cases(sbGeneal[1:3]),]
R> sbFiltIG <- dfToIG(sbFilt)
R> pathCL <- getPath("Clark", "Lawrence", sbFiltIG, sbFilt, "yield")
R> plotPath(pathCL, sbFilt, "yield") + ggplot2::xlab("Yield")
R> pathCL2 <- getPath("Clark", "Lawrence", sbFiltIG, sbFilt, "devYear")
R> plotPath(pathCL2, sbFilt, "devYear", "yield") + ggplot2::xlab("Development
+    Year") + ggplot2::ylab("Yield")
\end{Code}

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotPathQV2}}
    \caption{Left: Plotting a path of interest using a new quantitative variable of interest, ``Yield". Right: Plotting a path of interest using two quantitative variables. We see that the varieties \code{Clark} and \code{Lawrence} have lower yields than the varieties in the middle of the path.}
    \label{fig:plotPathQV2}
\end{figure}

\section{Superimposing shortest path on tree}
\label{sspt}

Now that we can create path objects, we may wish to know how those paths are positioned compared to the entire genealogical lineage. For instance, of the documented soybean cultivar lineage varieties, where does the shortest path between two varieties of interest exist? Are these two varieties older compared to the overall data structure? Are they newer? Or, do they span the entire structure, and represent two extreme ends of documented time points?

There is a function available in the \pkg{ggenealogy} package \code{plotPathOnAll()} that can allow users to quickly visualize their path of interest superimposed over all varieties and edges present in the whole data structure. Here we will produce a plot of the shortest path between varieties \code{Tokyo} and \code{Narow} across the entire dataset, as is displayed in Figure \ref{fig:plotTNBin3}.

\begin{Code}
R> plotPathOnAll(pathTN, sbGeneal, sbIG, "devYear", bin = 3, pathEdgeCol =
+    "red", nodeSize = 2.5, pathNodeSize = 4) + ggplot2::theme(axis.text =
+    ggplot2::element_text(size = 12), axis.title = ggplot2::element_text(size
+    = 12))
\end{Code}

\begin{figure}%[h]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotTNBin3}}
    \caption{The shortest path between \code{Tokyo} and \code{Narow}, superimposed over the data structure, using a bin size of 3.}
    \label{fig:plotTNBin3}
\end{figure}

In the code above, syntax from the \pkg{ggplot2} package was appended to the \code{plotPathOnAll()} function; this can be done for most \pkg{ggenealogy} functions. While the first four explicit parameters have been introduced earlier in this paper, the fifth parameter (\code{bin}) requires some explanation. The motivation of the \code{plotPathOnAll()} function is to write node labels on a plot, with the center of each node label constricted on the horizontal axis to its quantitative variable of interest (in this case, development year). As is the case for the plots before, the vertical axis has no meaning other than providing a plotting area in which to draw the node labels (unless a user specifies a second quantitative variable of interest, as we will demonstrate later). Unfortunately, for large datasets, this motivation can be a difficult task because the text labels of the varieties can overlap if they are assigned a similar y coordinate, have a similar year (x coordinate), and have long text labels (width of x coordinate).

For each variety, the x coordinate (year) and width of the x coordinate (text label width) cannot be altered, as they provide useful information. However, for each variety, the y coordinate is arbitrary. Hence, in an attempt to mitigate text overlapping, the \code{plotPathOnAll()} function does not randomly assign the y coordinate. Instead, it allows users to partially control the y coordinates with a user-determined number of bins (\code{bin}).

If the user decides to produce a plot using three bins, as in the example code above, then the varieties are all grouped into three bins based on their year values. In other words, there will be bin 1 (the ``oldest bin") which includes the one-third of varieties with the oldest years of release, bin 2 (the ``middle bin"), and bin 3 (the ``youngest bin"). Then, in order to decrease text overlap, the consecutively increasing y-axis coordinates are alternatively assigned to the three bins (For example: bin 1, bin 2, bin 3, bin 1, bin 2, bin 3, ...) repeatedly until all varieties are addressed. This algorithm means that for any pair of varieties within a given bin, there are exactly two other varieties vertically separating them.

\clearpage

In the code above, \code{bin} was assigned a value of 3, and \code{pathEdgeCol} was assigned a value of ``red". Additionally, we specified a size of 2.5 for the non-path node test using the \code{nodeSize} parameter, and a size of 4 for the path node text using the \code{pathNodeSize} parameter. There are several other parameters in the \code{plotPathOnAll()} function, which can be read in more detail using the help command.

This code resulted in Figure \ref{fig:plotTNBin3}, where we see that edges not on the path of interest are thin and gray by default, whereas edges on the path of interest are bolded by default. We also see that variety labels in the path of interest are boldfaced by default. Figure \ref{fig:plotTNBin3} presents useful information: We immediately gather that the path of interest does span most of the years of the data structure. In fact, \code{Tokyo} appears to be the oldest variety in the dataset, and \code{Narow} appears to be one of the youngest varieties. We can also determine that the majority of varieties were released between 1950 and 1970.

However, Figure \ref{fig:plotTNBin3} has significant empty spaces between the noticeably distinct bins, whereas almost all text labels are overlapping, thereby decreasing their readability. To force text labels into these spaces, the user may consider using a larger number of bins. Hence, we next examine a bin size of 6 to create Figure \ref{fig:plotTNBin6}.

\begin{Code}
R> plotPathOnAll(pathTN, sbGeneal, sbIG, "devYear", bin = 6, pathEdgeCol =
+    "seagreen2", nodeSize = 1, pathNodeSize = 3) + ggplot2::xlab("Development
+    Year")
\end{Code}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotTNBin6}}
    \caption{The shortest path between \code{Tokyo} and \code{Narow}, superimposed over the data structure, using a bin size of 6.}
    \label{fig:plotTNBin6}
\end{figure}

\clearpage

We can immediately see that Figure \ref{fig:plotTNBin6} more successfully mitigates text overlap compared to Figure \ref{fig:plotTNBin3}. We also confirm what we saw in the previous plot that most varieties were released between 1950 and 1970, and any textual overlap is confined to this range of years.

Notice again from Figure~\ref{fig:plotTNBin3} that the default horizontal axis label for the \texttt{plotPath()} method has a value of ``devYear". We wanted to change the default value of the horizontal axis label to ``Development Year". We did this in the code above for Figure~\ref{fig:plotTNBin6} by appending the \texttt{ggplot2::xlab()} function.

We would like to emphasize that the \code{plotPathOnAll()} method can be created with one or two quantitative variables that the user hard-codes. We demonstrate this using the filtered data frame and igraph objects (\code{sbFilt} and \code{sbFiltIG}) that we previously created to assure that there were no NA values in the quantitative variable ``yield". Then, we can examine the path across the remaining genealogical structure and how the quantitative variable ``yield" changes along the parent-child relationships of that path. Likewise, we can plot how the quantitative variables ``devYear" and ``yield" both change along the parent-child relationships of that path. The output of these two calls to the \code{plotPathOnAll()} function can be viewed in Figure \ref{fig:plotPathOnAllQV2}.

\begin{Code}
R> plotPathOnAll(pathCL, sbFilt, sbFiltIG, "yield", bin = 3, pathEdgeCol =
+    "purple") + ggplot2::xlab("Yield")
R> plotPathOnAll(pathCL, sbFilt, sbFiltIG, "yield", "devYear", pathEdgeCol =
+    "orange") + ggplot2::xlab("Yield") + ggplot2::ylab("Development Year")
\end{Code}

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotPathOnAllQV2}}
    \caption{Left: Plotting a path of interest across the genealogical structure using a new quantitative variable of interest, ``Yield". Right: Plotting a path of interest across the genealogical structure using two quantitative variables. We see that an increase in development year might correlate to an increase in yield for the varieties in this dataset, and that our path of interest is composed of generally younger varieties compared to the dataset as a whole.}
    \label{fig:plotPathOnAllQV2}
\end{figure}

\section{Plotting ancestors and descendants by generation}
\label{remedy}

The most novel visual function in \pkg{ggenealogy}, \code{plotAncDes()} allows users to view the ancestors and descendants of a given variety. The inputted variety is highlighted in the center of the plot, ancestors are displayed to the left of the center, and descendants are displayed to the right of the center. The further from the center that a variety is located, the more generations that variety is distanced from the centered variety of interest. This particular \pkg{ggenealogy} tool is uniquely beneficial because most genealogy and graph visualization software do not allow for repeated node labels even though some genealogical datasets require repeated node labels in order to be visualized by generation counts (as was shown in Figures \ref{fig:kinshipFig} and \ref{fig:Graph}).

To demonstrate this tool, we will create a plot of the ancestors and descendants of the variety \code{Lee}. We specify that the maximum number of ancestor and descendant generations are both 6, and that the text of the variety of interest is highlighted in blue:

\begin{Code}
R> plotAncDes("Lee", sbGeneal, mAnc = 6, mDes = 6, vCol = "blue")
\end{Code}

This generates the top plot of Figure \ref{fig:Lee}. We notice that \code{Lee} has 3 generations of ancestors and 5 generations of descendants. We also notice that some varieties are repeated, which is a unique feature provided by \pkg{ggenealogy}. For example, the variety \code{5601T} is represented four times - once as a third generation descendant of \code{Lee}, once as a fourth generation descendant of \code{Lee}, and twice as a fifth generation descendant of \code{Lee}. The variety \code{5601T} was repeated multiple times because there are multiple paths between \code{Lee} and \code{5601T}. For explanation purposes, all paths between \code{Lee} and \code{5601T} were manually highlighted in blue.

The bottom plot of Figure \ref{fig:Lee} is not an output plot of \pkg{ggenealogy}. Instead, it was simply created for didactic purposes. Here, the paths that were manually highlighted in blue in the top plot produced by \pkg{ggenealogy} are shown again, only now nodes cannot be repeated. The parenthetical number above each node represents the set of generation counts distancing that node from the center node \code{Lee}; green parentheses indicate that the node could be successfully placed in one horizontal position, but red parentheses indicate that the node could not be successfully placed in one horizontal position. We see that node \code{TN89-39} cannot simultaneously be represented as both a third and fourth descendent of node \code{Lee}, and node \code{5601T} cannot simultaneously be represented as a third, fourth, and fifth descendent of node \code{Lee}. Hence, without allowing nodes to repeat, this dataset cannot be presented in the graph on the bottom as it can be in the \pkg{ggenealogy} graph on the top. This is a current limitation in other genealogy and graphical software that \pkg{ggenealogy} can now provide.

\section{Plotting distance matrix}
\label{pdm}

It may also be of interest to generate matrices where the colors indicates a variable between all pairwise combinations of inputted varieties. The package \pkg{ggenealogy} also provides a function \code{plotDegMatrix()} for that purpose. We can demonstrate this function with the variable being the shortest path degree between a given pair of varieties. The shortest path degree is calculated as the smallest number of parent-child edges needed to traverse between two varieties of interest. For instance, in Figure \ref{fig:pathTNZB}, the shortest path degree between \code{Tokyo} and \code{Narow} is four and the shortest path degree between \code{Bedford} and \code{Zane} is ten.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=\textwidth]{LeeAD}}
    \caption{Top: All ancestors and descendants of the variety \code{Lee} are shown in this \pkg{ggenealogy} plot. Bottom: For didactic purposes, this plot was constructed manually outside of the \pkg{ggenealogy} package. It mimics the blue paths in the \pkg{ggenealogy} plot on the top, only now nodes cannot be repeated. The parenthetical numbers above each node represents the set of generation counts that node is away from the center node \code{Lee}. The presence of red parentheses indicate that the plot on the bottom ambiguously display the example soybean genealogy in the way that the \pkg{ggenealogy} plot on the top can accomplish.}
    \label{fig:Lee}
\end{figure}

Here we generate a distance matrix for a set of 10 varieties, setting the x-label and y-label as ``Variety" and the legend label as ``Degree". In this example, we add \pkg{ggplot2} functionality to specify that pairs with small degrees are white, while those with large degrees are dark green, as well as to specify the text size of the legend title and label.

\begin{Code}
>R varieties <- c("Brim", "Bedford", "Calland", "Dillon", "Hood", "Narow",
+    "Pella", "Tokyo", "Young", "Zane")
>R plotDegMatrix(varieties, sbIG, sbGeneal) + ggplot2::scale_fill_continuous
+    (low = "white", high = "darkgreen") + ggplot2::theme(legend.title =
+    ggplot2::element_text(size = 15), legend.text = ggplot2::element_text
+    (size = 15)) + ggplot2::labs(x = "Variety", y = "Variety")
\end{Code}

This creates the plot in Figure \ref{fig:degMatrix}. We see that the degree of the shortest path between varieties \code{Bedford} and \code{Zane} is 10, which is consistent with what we saw earlier in Figure \ref{fig:pathTNZB}. However, we now also see that a shortest path degree of 10 may be considered relative to the rest of this dataset.

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.5\textwidth]{degMatrix}}
    \caption{The shortest path degree matrix between ten varieties of interest.}
    \label{fig:degMatrix}
\end{figure}

\section{Academic genealogy of statisticians}

An academic genealogy is the second dataset provided in the package, where every parent is also a child and some children have more than two parents, as was briefly described in Section \ref{exData}. Neither of these features was the case in the plant breeding genealogy. Additionally, the academic genealogy is much larger than the plant breeding genealogy. Some of these differences may affect how one would approach \pkg{ggenealogy} plotting tools. For this reason, we will now demonstrate some of the \pkg{ggenealogy} plotting tools we already introduced, only now applied to the academic genealogy. 

The ability to plot ancestors and descendants by generation was demonstrated using the plant breeding genealogy in Figure \ref{fig:Lee}. As we believe this is the most novel plotting tool in the \pkg{ggenealogy} package, we will test it again here using the academic genealogy.

We need to choose a central individual of interest in order to create this plot. Perhaps we can use the academic statistician in the dataset that has the largest number of ``descendants". To determine the name of this individual, below we use the \pkg{ggenealogy} function \code{getNode()} to create a vector \code{indVec} that contains the names of all individuals in the dataset. We then use the \pkg{dplyr} package to apply the \pkg{ggenealogy} function \code{getDescendants()} on each individual in the \code{indVec} vector (\citealt{dplyr}). We set the parameter \code{gen} to a conservatively large value of 100 as this dataset is unlikely to have any individuals with more than 100 generations of ``descendants".

After that, we can generate a table to examine all values of ``descendant" counts in the dataset, along with the number of individuals who have each of those values of ``descendant" counts. Of the 8165 individuals in this dataset, 6252 of them have zero ``descendants", 322 of them have one ``descendant", and 145 of them have two ``descendants". There are only 17 individuals who have more than 30 ``descendants", and there is one individual who has the largest value of 159 ``descendants". We determine that this individual is the prominent British statistician Sir \code{David Cox}, who is known for the Box-Cox transformation and Cox processes, as well as for mentoring many younger researchers who later became notable statisticians themselves.

\begin{CodeChunk}
\begin{CodeInput}
>R library("dplyr")
>R indVec <- getNodes(statGeneal)
>R indVec <- indVec[which(indVec != "", )]
>R dFunc <- function(var) nrow(getDescendants(var, statGeneal, gen = 100))
>R numDesc <- sapply(indVec, dFunc)
>R table(numDesc)
\end{CodeInput}
\begin{CodeOutput}
numDesc
   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14 
6251  322  145   88   58   36   31   22   23   14   17   13   14   10    9 
  15   16   17   18   19   20   21   22   23   24   25   26   27   29   30 
   6    4    3    2    5    7    4    3    3    2    2    6    1    1    3 
  34   37   38   40   41   44   45   48   49   60   61   75   77   84  159 
   2    1    1    1    1    1    1    1    2    1    1    1    1    1    1 
\end{CodeOutput}
\begin{CodeInput}
R> which(numDesc == 159)
\end{CodeInput}
\begin{CodeOutput}
David Cox 
     1980
\end{CodeOutput}
\end{CodeChunk}

We can now visualize how these 159 ``descendants" are related to Sir \code{David Cox} by calling the \code{plotAncDes()} function of \pkg{ggenealogy}, similar to what we did to generate Figure \ref{fig:Lee}. As such, we create Figure \ref{fig:dCox} using the code below.

\begin{CodeInput}
R> plotAncDes("David Cox", statGeneal, mAnc = 6, mDes = 6, vCol = "blue")
\end{CodeInput}

\begin{figure}%[h]
    \centering
    \fbox{\includegraphics[width=\textwidth]{dCox.png}}
    \caption{The 159 academic statistician ``descendants" of Sir \code{David Cox}.}
    \label{fig:dCox}
\end{figure}

We see from Figure \ref{fig:dCox} that Sir \code{David Cox} had 42 ``children", many of them becoming notable statisticians themselves, such as \code{Basilio Pereira}, \code{Valerie Isham}, \code{Gauss Cordeiro}, \code{Peter McCullagh}, and \code{Henry Wynn}. Of his ``children", the one who produced the most ``children" of their own was \code{Peter Bloomfield}, who has 26 ``children" and 49 ``descendants". In total, Sir \code{David Cox} had five generations of academic statistics mentees in this dataset.

\begin{CodeChunk}
\begin{CodeInput}
R> length(getChild("Peter Bloomfield", statGeneal))
\end{CodeInput}
\begin{CodeOutput}
[1] 26
\end{CodeOutput}
\begin{CodeInput}
R> nrow(getDescendants("Peter Bloomfield", statGeneal, gen = 100))
\end{CodeInput}
\begin{CodeOutput}
[1] 49
\end{CodeOutput}
\end{CodeChunk}

At this point, it would be insightful to examine a more detailed view of one of the longest strings of ``parent-child" relationships between Sir \code{David Cox} and one of the two individuals who are his fifth generation ``descendants". We do so with the code below, choosing his fifth generation ``descendant" to be \code{Petra Buzkova}. We set the \code{fontFace} variable of the \code{plotPath()} to a value of 4, indicating we wish to boldface and italicize the two statisticians of interest.

\begin{CodeChunk}
\begin{CodeInput}
R> statIG <- dfToIG(statGeneal)
R> pathCB <- getPath("David Cox", "Petra Buzkova", statIG, statGeneal,
+    "gradYear", isDirected = FALSE)
R> plotPath(pathCB, statGeneal, "gradYear", fontFace = 4) + ggplot2::xlab
+    ("Graduation Year") + ggplot2::theme(axis.text = ggplot2::element_text
+    (size = 10), axis.title = ggplot2::element_text(size = 10)) +
+    ggplot2::scale_x_continuous(expand = c(.1, .2))
\end{CodeInput}
\end{CodeChunk}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=0.7\textwidth]{pathCB}}
    \caption{The shortest path between Sir \code{David Cox} and one of his fifth generation ``descendants", \code{Petra Buzkova}.}
    \label{fig:pathCB}
\end{figure}

This code results in Figure \ref{fig:pathCB}. We see that the shortest path between Sir \code{David Cox} and \code{Petra Buzkova} is strictly composed of five unidirectional ``parent-child" relationships that span about 55 years. We see that the time difference between when an advisor and student earned their degrees is not consistent across this path: The three statisticians who earned their degrees earliest in this path span more than 30 years in degree acquisition, whereas the three statisticians who earned their degrees later in this path only span less than ten years in degree acquisition.

We also notice in Figure \ref{fig:pathCB} that Sir \code{David Cox} received his statistics degree in about 1950, and \code{Petra Buzkova} received her statistics degree in about 2005. This genealogy only contains historical information about obtained degrees, and does not project into the future. Hence, we can be assured that \code{Petra Buzkova} is one of the younger individuals in the dataset, at least in the sense that the youngest individual could only have received his or her degree ten years after \code{Petra Buzkova}. However, we cannot be assured that Sir \code{David Cox} is one of the oldest individuals in the dataset. As such, it would be informative to superimpose this path of interest onto the entire dataset, using the \code{plotPathOnAll()} function of the \pkg{ggenealogy} package, as we did for the soybean genealogy in Figures \ref{fig:plotTNBin3} and \ref{fig:plotTNBin6}.

We can achieve this using the below code. After trial and error, we use a \code{bin} of size 200, and append \pkg{ggplot2} syntax to define suitable x-axis limits. The output of this process is illustrated in Figure \ref{fig:plotCBText}.

\begin{CodeChunk}
\begin{CodeInput}
R> plotPathOnAll(pathCB, statGeneal, statIG, "gradYear", bin = 200) +
+    ggplot2::theme(axis.text = ggplot2::element_text(size = 8), axis.title =
+    ggplot2::element_text(size = 8)) + ggplot2::scale_x_continuous
+    (expand = c(.1, .2)) + ggplot2::xlab("Graduation Year")
\end{CodeInput}
\end{CodeChunk}

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotCBText}}
    \caption{The shortest path between Sir \code{David Cox} and \code{Petra Buzkova}, superimposed over the data structure, using a bin size of 200.}
    \label{fig:plotCBText}
\end{figure}

We see from the resulting Figure \ref{fig:plotCBText} that almost all text labels for individuals who received their graduate-level statistics degrees between 1950 and 2015 are undecipherable. We also see that the year Sir \code{David Cox} acquired his statistics degree is somewhere in the later half of the variable year for this dataset, as the oldest dates for acquisition of statistics degrees in this dataset occur around 1860. However, the number of individuals who are documented as receiving their statistics degrees between 1860 and 1950 are few enough so that their text labels are somewhat readable.

The text labels are so numerous in Figure \ref{fig:plotCBText} that simply trying different values for the input parameter \code{bin} will not solve the text overlapping problem. Instead, one approach we can try is to reconstruct the plot using the same \pkg{ggenealogy} function \code{plotPathOnAll()}, only now specifying variables to render the size (2.5) and color (default of black) of the text for nodes that are on the path of interest to be more noticeable than the size (0.5) and color (dark gray) of the text for nodes that are not on the path of interest. Moreover, we can make the edges that are not on the path of interest to be represented in a less noticeable color (light gray) than the edges that are on the path of interest (default of dark green). The variable names and options for these aesthetics is further detailed in the help manual of the function. We provide one example code that alters the defaults of the text color and sizes of nodes and edges below, which results in Figure \ref{fig:plotCBNoText}.

\begin{CodeChunk}
\begin{CodeInput}
R> plotPathOnAll(pathCB, statGeneal, statIG, "gradYear", bin = 200, nodeSize =
+    .5, pathNodeSize = 2.5, nodeCol = "darkgray", edgeCol = "lightgray") +
+    ggplot2::theme(axis.text = ggplot2::element_text(size = 8), axis.title =
+    ggplot2::element_text(size = 8)) + ggplot2::scale_x_continuous
+    (expand = c(.1, .2)) + ggplot2::xlab("Graduation Year")
\end{CodeInput}
\end{CodeChunk}

In Figure \ref{fig:plotCBNoText}, we can now see each individual on the path of interest, and how their values for the variable year are overlaid on the entire genealogy structure. We can also more clearly see that, even though only ten years span between the youngest individual in the genealogy and \code{Petra Buzkova}, there are many individuals in that last decade. Indeed, the decade from 2005 to 2015 appears to be the densest in this dataset in terms of acquisition of statistics degrees.

\section{Interactive plotting functions}
\label{interaction}

We could still improve upon Figure \ref{fig:plotCBNoText}. Even though we may be primarily interested in understanding how the path of interest is overlaid across the entire genealogical structure, we could, upon viewing the entire structure, also develop an interest in nodes that are not on the path of interest but are revealed to stand out among the rest of the genealogical structure. For instance, in Figure \ref{fig:plotCBNoText}, it may be of interest for us to determine the names of the few individuals who obtained their statistics degrees before 1900. Fortunately, within the \code{plotPathOnAll()} function, there is a variable \code{animate} that we can set to a value of TRUE to create an interactive version of the figure that allows us to hover over individual illegible labels and immediately receive their labels in a readable format. This interactive functionality comes from methods in the \pkg{plotly} package (\citealt{plotly}). A short video demonstration of these interactive features can be viewed in Figure \ref{fig:plotAnimate}.

\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=\textwidth]{plotCBNoText}}
    \caption{The shortest path between Sir \code{David Cox} and \code{Petra Buzkova}, superimposed over the data structure, using a bin size of 200. Individuals on the shortest path are labeled in large and black text and connected by dark green edges; all other individuals are labeled in small and gray text and connected by light gray edges.}
    \label{fig:plotCBNoText}
\end{figure}

\begin{CodeChunk}
\begin{CodeInput}
R> plotPathOnAll(pathCB, statGeneal, statIG, "gradYear", bin = 200, nodeSize =
+    .5, pathNodeSize = 2.5, nodeCol = "darkgray", edgeCol = "lightgray",
+    animate = TRUE)
\end{CodeInput}
\end{CodeChunk}

We would like to state that users can still hard code one or two variables in the \code{plotPathOnAll()} function, even with the \code{animate} option set to a value of ``TRUE". The first call to the \code{plotPathOnAll()} function below would produce an interactive plot with the yield on the horizontal axis. When hovering over labels, the label name and yield value would be revealed. The second call to the \code{plotPathOnAll()} function below would produce an interactive plot with the yield on the horizontal axis and development year on the vertical axis. When hovering over labels, the label name, yield value, and development year would be revealed. We do not include the animated videos that the below code creates in this document, but readers can use the below code to create them on their own.

\begin{Code}
R> plotPathOnAll(pathCL, sbFilt, sbFiltIG, "yield", pathEdgeCol = "orange",
+    animate = TRUE)
R> plotPathOnAll(pathCL, sbFilt, sbFiltIG, "yield", "devYear", pathEdgeCol =
+    "orange", animate = TRUE)
\end{Code}

\begin{figure}[H]
    \centering
    \fbox{\includemedia[label = v1, playbutton=none, width=1.0\textwidth, addresource=animateGen.mov, activate=pageopen, flashvars={source=animateGen.mov}]{\includegraphics{./plotCBNoText.png}}{VPlayer.swf}}
    \mediabutton[mediacommand=v1:playPause,]{\mybox{Play/Pause}}
    \caption{A short video demonstrating the animation features for this function. Please note that to properly view this video, the PDF version of this document must be opened in Adobe Acrobat Reader DC (version >=9), which can be downloaded free of charge. This video can only be viewed on Windows or Mac OS X platforms; it cannot be viewed on mobile devices.}
    \label{fig:plotAnimate}
\end{figure}

\section{Branch parsing and calculations}

It may be helpful for users to search through descendant branches of a certain individual to compare and contrast how a variable of interest changes along those branches. For instance, which descending branches of a particular soybean variety are producing the highest yields? Which branches are developing new varieties in recent years? Which descending branches of a particular academic statistician have large proportions of students graduating from certain universities or countries? Which branches are graduating new students in recent years? Which branches have the highest proportion of thesis titles containing a word of interest?

Answering these questions in a straightforward manner requires more than basic data frame manipulation: It also requires methods that can easily traverse parent-child relationships. The \pkg{ggenealogy} package has two methods that can answer these questions using branch traversal. The \code{getBranchQuant()} function can be used to track a quantitative variable across branches and the \code{getBranchQual()} method can be used to track a qualitative variable across branches.

\clearpage
\subsection{Quantitative variable parsing and calculations}

We can demonstrate the \code{getBranchQuant()} function by examining the quantitative variable ``yield" across the descendant branches of the soybean variety \code{A.K.} To understand more about the output of this function, please consult the \pkg{ggenealogy} package documentation. In the code below, we remove the output column ``DesNames" because it verbosely lists all descendant names, which is not necessary for this demonstration.

\begin{CodeChunk}
\begin{CodeInput}
R> AKBranchYield <- getBranchQuant("A.K.", sbGeneal, "yield", 15)
R> select(AKBranchYield, -DesNames)
\end{CodeInput}
\begin{CodeOutput}
           Name     Mean       SD Count NACount
1 A.K. (Harrow) 2932.154 197.0092    54      41
2        Illini 2856.667 210.7801   131     125
\end{CodeOutput}
\end{CodeChunk}

We see from the output that \code{A.K.} has two children named \code{A.K. (Harrow)} and \code{Illini}. Descendants from the \code{A.K. (Harrow)} branch have a higher mean yield than the \code{Illini} branch (2932.154 versus 2856.667). However, we should recognize that even though the branches contain a large number of descendants (54 and 131), most of these descendants did not come with a yield value (41 and 125). As a result, the mean values were calculated from a small proportion of the descendants.

As another example, we can examine the mean graduation year for the ``descendant" branches of the academic statistician \code{David Cox}. We know from earlier that \code{David Cox} had 42 ``children", so as expected, the \code{CoxBranchYear} object below contains 42 rows. However, only 8 of these rows have any ``descendants" of their own. As a result, only the first 8 rows of the \code{CoxBranchYear} object contain branch information.

\begin{CodeChunk}
\begin{CodeInput}
R> CoxBranchYear <- getBranchQuant("David Cox", statGeneal, "gradYear", 15)
R> head(select(CoxBranchYear, -DesNames), 10)
\end{CodeInput}
\begin{CodeOutput}
                         Name     Mean        SD Count NACount
1                 Mark Berman 2007.200  6.340347     5       0
2                  Henry Wynn 2005.333  7.637626     3       0
3                Rodney Wolff 2003.500  2.121320     2       0
4                 Jane Hutton 2003.000        NA     1       0
5              Gauss Cordeiro 2002.643  7.722167    14       0
6             Peter McCullagh 2001.231  8.778645    26       0
7             Basilio Pereira 2000.647 10.074356    17       0
8            Peter Bloomfield 1999.918 11.707969    49       0
9            Adelchi Azzalini      NaN        NA     0       0
10 Amy Berrington de Gonzales      NaN        NA     0       0
\end{CodeOutput}
\end{CodeChunk}

In this case, we see that of the 8 ``children" of \code{David Cox} who had ``children" of their own, \code{Mark Berman} had the ``descendants" (n=5) who have on average graduated the most recently (2007.200), whereas \code{Peter Bloomfield} has the ``descendants" (n=49) who on average have graduated the least recently (1999.918). We see that, for all branches, there are no ``descendants" who contain a NA value for graduation year.

\clearpage
\subsection{Qualitative variable parsing and calculations}

The \code{getBranchQual()} function requires similar inputs as the \code{getBranchQuant()} function above, except that it also requires an input parameter called \code{rExpr}. The user must initialize this input parameter to a regular expression that can be applied to the column containing the qualitative variable of interest. The regular expression syntax must work on a data frame column of type character. It must be saved as a double quotation string, and any quotation marks within it must be single quotations. The term \code{geneal\$colName} must be used in the regular expression.

We can demonstrate the \code{getBranchQual()} function by examining the qualitative variable ``thesis" across the ``descendant" branches of the academic statistician \code{David Cox}. Since one of the primary research areas for \code{David Cox} was stochastic processes, we can determine if any descendant branches of his ``children" contained thesis titles that included the word ``stochastic".

\begin{CodeChunk}
\begin{CodeInput}
R> v1 = "David Cox"; geneal = statGeneal; colName = "thesis"; gen = 15
R> rExpr = "grepl('(?i)Stochastic', geneal$colName)"
R> CoxBranchStochastic <- getBranchQual(v1, geneal, colName, rExpr, gen)
R> head(select(CoxBranchStochastic, -DesNames))
\end{CodeInput}
\begin{CodeOutput}
                        Name CountTrue Count NACount
1           Peter Bloomfield         4    49       0
2            Basilio Pereira         1    17       0
3           Adelchi Azzalini         0     0       0
4 Amy Berrington de Gonzales         0     0       0
5              Andrew Roddam         0     0       0
6            Angela Mariotto         0     0       0
\end{CodeOutput}
\end{CodeChunk}

We see that only two ``children" of \code{David Cox} had any ``descendants" with thesis titles containing the word ``Stochastic" (4 out of 49 ``descendants" of \code{Peter Bloomfield} and 1 out of 17 ``descendants" of \code{Basilio Periera}). We see again that none of the ``descendants" from either branches contained values that were NA for the variable ``thesis".

In many string parsing applications, the choice of the regular expression can be tricky. This is true when the string variable we are parsing is thesis titles. For instance, notice that in our regular expression, we accounted for all instances of the substring ``Stochastic". Hence, words that contain "Stochastic" (such as ``Stochastics" and ``Stochastically") will also be returned. In addition, we defined our regular expression to return matches whether the first letter was upper or lower case. When initializing the \code{rExpr} parameter, users would need to consider what nuances of their search criteria they would like to define as matches.

We will demonstrate one more example of the \code{getBranchQual()} function by searching the qualitative variable ``school" across the ``descendant" branches of the academic statistician \code{David Cox}. The Mathematics Genealogy Project coding system for the ``school" variable was non-ambiguous, and so we do not have to worry about all the various ways the same school could be coded in the dataset. As a result, we no longer have to search for various substrings; we can simply use a regular expression that equates to one value.

It may be interesting to examine the school that is represented the most among all descendants of \code{David Cox}. To determine what school this is, we use the \code{getDescendants()} function to create a data frame called \code{desDC} that contains the names of all 159 ``descendants" of \code{David Cox}. Then, we use the base R function \code{match()} to match the school names from the original genealogy dataset to each of the 159 ``descendants" in the \code{desDC} data frame. After that, we use the base R functions \code{sort()} and \code{table()} to examine the five schools that were represented the most throughout the 159 ``descendants".

\begin{CodeChunk}
\begin{CodeInput}
R> desDC <- getDescendants("David Cox", statGeneal, 15)
R> tableDC <- table(statGeneal[match(desDC$label, statGeneal$child), ]$school)
R> tail(sort(tableDC), 5)
\end{CodeInput}
\begin{CodeOutput}
          The Johns Hopkins University 
                                     9 
Universidade Federal do Rio de Janeiro 
                                    17 
       North Carolina State University 
                                    18 
             Universidade de So Paulo 
                                    28 
                  University of London 
                                    35
\end{CodeOutput}
\end{CodeChunk}

We see from this table that the most common school of the 159 ``descendants" of \code{David Cox} was the University of London with a count of 35. We can now determine which of the branches from the 42 ``children" of \code{David Cox} have the largest proportion of ``descendants" graduating from the University of London.

\begin{CodeChunk}
\begin{CodeInput}
R> colName = "school"
R> rExpr = "geneal$colName=='University of London'"
R> DCBranchUL <- getBranchQual(v1, geneal, colName, rExpr, gen)
R> head(select(DCBranchUL, -DesNames))
\end{CodeInput}
\begin{CodeOutput}
                        Name CountTrue Count NACount
1            Peter McCullagh         1    26       0
2           Adelchi Azzalini         0     0       0
3 Amy Berrington de Gonzales         0     0       0
4              Andrew Roddam         0     0       0
5            Angela Mariotto         0     0       0
6             Basil Springer         0     0       0
\end{CodeOutput}
\end{CodeChunk}

We see that \code{Peter McCullagh} is the only ``child" of \code{David Cox} that has a ``descendant" branch with one student graduating from the University of London; the rest of the 41 children of \code{David Cox} have ``descendant" branches with zero students graduating from the University of London. This must mean the other 34 ``descendants" of \code{David Cox} that graduated from the University of London were direct ``children" of \code{David Cox}. We can verify this below:

\begin{CodeChunk}
\begin{CodeInput}
R> DCChild <- statGeneal[match(getChild("David Cox", statGeneal),
+    statGeneal$child), ]
R> sum(DCChild$school == "University of London")
\end{CodeInput}
\begin{CodeOutput}
[1] 34
\end{CodeOutput}
\end{CodeChunk}

The examples above demonstrate that users can quickly and flexibly parse descendant branches. The swiftness comes from \pkg{ggenealogy} functions that allow for fast parent-child traversals, such as \code{getChild()}, \code{getDescendants()}, \code{getBranchQuant()}, and \code{getBranchQual()}. The flexibility comes from data frame manipulation functions in base R that can be used in conjunction with the parent-child traversal methods.

\section{Future avenues}

Incorporation of the Shiny application allows users to examine \pkg{ggenealogy} tools in a more interactive way (\citealt{shiny}). The reactive programming saves them the time of using command-line for each change of input as well as the inefficiency of rerunning code. A Shiny application that uses certain \pkg{ggenealogy} functionality is available for users who wish to explore the soybean genealogy; the data can be viewed at \url{http://shiny.soybase.org/CNV/}.

We also aim to incorporate plotting tools that can examine not only quantitative variables (such as our example variable of ``year"), but also categorical variables associated with individuals in datasets. Moreover, we look forward to testing the \pkg{ggenealogy} package on additional genealogical data sets. Exploring several datasets with the software will allow us to fix remaining bugs, and provide us further insight into how to make our tools available for a wide range of data input formats. 

The \pkg{ggenealogy} visualization tool \code{plotPathOnAll()} is suitable as a data exploration tool, but not always as a publication tool. This is because we still see textual overlap in small-enough datasets (see Figure \ref{fig:plotTNBin6}). As such, we plan to add a feature to the package that allows users to manually fine-tune automated plots. For example, after comparing several bin sizes on the soybean genealogy, we determined that the bin size of 6 produced the minimal textual overlap, as is seen in Figure \ref{fig:plotTNBin6}. If we could subsequently fine-tune the vertical positions of the small fraction of text labels that remained overlapped after the automated \pkg{ggenealogy} function, then we could potentially remove all overlaps, and the plot could be used in presentations and publications. Of course, it is impossible to eliminate textual overlap in larger datasets (see Figure \ref{fig:plotCBText}). In such cases, we can remedy this problem by representing individuals who are not on the path of interest with dots instead of text (see Figure \ref{fig:plotCBNoText}).

\section{Conclusions}

The \pkg{ggenealogy} package offers various plotting tools that can assist those studying genealogical lineages in the data exploration phases, as well as in preparing publication-suitable images. As each plot comes with its pros and cons, we recommended for users to explore several visualization tools. If users are simultaneously using similar packages, we in particular recommend using the \code{plotAncDes()} function. This plot allows users to view generation counts of a variety of interest in a manner that is not as readily available in similar software packages.

\clearpage
\section*{Acknowledgments}

The authors thank Drs. James E. Specht and Randy C. Shoemaker for helpful discussions of soybean genealogy. In addition, the authors are grateful for the financial support from the United Soybean Board (Project 1204), The North Central Soybean Research Program, the NSF Plant Genome Research Program (award number 0820642), and the USDA-ARS CRIS Project 3625-21220-005-00D. The USDA is an equal opportunity provider and employer. Mention of trade names or commercial products in this article is solely for the purpose of providing specific information and does not imply recommendation or endorsement by the U.S. Department of Agriculture. Author Cook was a faculty member at Iowa State University at the time that most of this work was conducted.

\clearpage

\bibliography{article}

\end{document}